## 赛题分析

* 地图大小为`12×12`，需求点固定为`5`个，配送目标是将所有需求点的需求进行满足

* 配送过程中，捐赠点每`10-20步`会随机生成一个
  > 这里我的理解出现了偏差，官方的赛题详情中提到：
  > ![image.png](./102422h6tc4wjrgwezkdpq.png)
  > 我起初理解为了空间概念，即捐赠点会在花费`10-20步`可以走到的距离内随机生成，但万万没想到这其实是个时间概念，是在每`10-20步`的时间内会随机生成一个捐赠点。由于这个理解偏差，很自然地也被**捐赠点砸脸**困扰了一阵，也许在这里官方的表述可以更清晰些。

* 纯命令行交互，使用标准I/O作为`命令（S/R/G）`和`移动方向(E/W/S/N)`的传递途径

* 最后在**1000张**地图上判分，用时不超过**5分钟**，取花费的平均步数作为成绩

## 算法思路

### 人脑规划

看到这个赛题，我首先想到的是：**如果是我正在骑着电动车，我会怎么安排配送？**

直觉上我觉得应该从最近的需求点送起，同时还要避免出现无意义的跑动，比如当身上只有10个口罩而需求点需求90个时，我可能更好的方案是先收集齐了90个再去而不是选择先过去卸下身上的10个。

基于这个直觉，我首先搜索出满足以下条件的需求点或捐赠点：

* 身上携带的口罩能够满足的需求点

* 身上携带的口罩虽不能满足，但送去后再返回仓库折返一次就可满足的需求点

* 对于某需求点，身上携带的口罩虽不能满足，但去n个捐赠点收集后就可满足且花费步数比回仓库折返更少时，首先经过的捐赠点（*找这n个捐赠点时我还写了个让我沾沾自喜的递归。。。*）

然后在这些点中选择距离我最近的那个点作为目的地。之后每到达一个点，就依照上边的方法再搜索选择，直到所有需求点都被满足。

这个思路很简单，能够取得平均**97步**左右的成绩，但没什么提升空间。这样一个简单思路所找出来的路径必然不会是最优的，只是因为人脑计算力不够而想出的直觉方法。

**人脑规划不行，那就还是需要用到计算机擅长的暴力搜索。**

### 电脑规划

Dijkstra算法是很经典的路径规划算法，本质上就是暴力搜索，适用于**寻找两个顶点之间的最短路径**。那在口罩配送这个问题上该如何暴力搜起来？

首先需要确定这里的两个**顶点**分别是什么，由于我们不是要简单地在二维地图上规划一点到另一点的距离（因为涉及到很多状态量的变化），所以这两个顶点所包含的信息显然不仅仅是坐标。事实上，每走出一步都会影响到很多状态量的变化，而我们要寻找的是如何花费最少的步数来使得我们从**`快递员准备首次从仓库出发`**这个状态到达**`所有需求点被满足`**这个状态。

以下这些量是移动过程中会发生变化的量，它们之间的所有排列组合即为我们要搜索的**状态空间**：

* 快递员当前位置的横坐标`X`、纵坐标`Y`

* 快递员当前携带量`Q`

* 地图上各点对应的需求量或捐赠量`MAP_Q[12][12]`

这样一来，两个顶点的状态也就确定了：

* 起点：`X=仓库横坐标`，`Y=仓库纵坐标`，`Q=100`，`MAP_Q`按照指令输入赋值

* 终点：`X=最后一个被满足的需求点横坐标`，`Y=最后一个被满足的需求点纵坐标`，`Q&lt;100`，`MAP_Q`中5个需求点对应的需求量为`0`

接下来还要明确**状态是如何变化的**：

* 快递员每次在X轴或Y轴上走一步，`X`和`Y`会发生变化

* 每当进入需求点、捐赠点或仓库时，`Q`会发生变化，被进入点的需求量或捐赠量也会发生变化，代码如下
> ```C++
> if ( (X,Y) == 仓库 )
> {
>     Q = 100;
> }
> else
> {
>     SUM_Q = Q + MAP_Q[X][Y];
>     if (SUM_Q > 100)
>     { 
>         MAP_Q[X][Y] = SUM_Q - 100;
>         Q = 100;
>     }
>     else if (SUM_Q      {
>         MAP_Q[X][Y] = SUM_Q;
>         Q = 0;
>     }
>     else
>     {
>         MAP_Q[X][Y] = 0;
>         Q = SUM_Q;
>     }
> }
> ```

有了以上这些定义，就可以开始暴力搜索了，具体如何搜索可以参看代码。

这个思路大大地减少了花费步数，经过优化最终成绩逼近了**90步**大关~






